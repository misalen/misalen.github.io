{"meta":{"title":"Misalen's Blog","subtitle":null,"description":"我","author":"Misalen","url":"https://misalen.github.io"},"pages":[{"title":"","date":"2017-12-18T10:04:41.213Z","updated":"2017-12-18T10:04:41.213Z","comments":true,"path":"about/index.html","permalink":"https://misalen.github.io/about/index.html","excerpt":"","text":"关于我 从事 WEB 开发，主要开发语言 JAVA，熟悉使用 Spring、Hibernate 等主流框架；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作 城市：北京 关于学习 近期学习方向：数据交换系统 关于座右铭 身正不令而从。 人可以死，这张皮老子要绷着。 关于爱好 热爱游戏，喜爱电子产品、阅读、搞笑剧、旅行。 联系我 Home: zhaoguochao.com Blog: misalen.github.io Email: misalen@qq.com GitHub: Misalen"}],"posts":[{"title":"MisalenSpring系列 -1- 简介","slug":"misalen-spring系列-1-简介","date":"2017-12-19T03:53:51.000Z","updated":"2017-12-19T10:11:45.071Z","comments":true,"path":"2017/12/19/misalen-spring系列-1-简介/","link":"","permalink":"https://misalen.github.io/2017/12/19/misalen-spring系列-1-简介/","excerpt":"","text":"基本工具：JDK、Eclipse、Maven前端：Jquery、bootstrap.js、layui.js后台核心框架：SpringBoot（Sprnig、SpringMvc）、JPA（Hibernate）后台辅助框架：日志框架Logback、安全框架Shiro、任务调度框架Quartz、HTML模板框架Thymeleaf、缓存支持ehcache分布式框架：暂缺 项目采用maven分模块结构，支持分包和集中部署，各个模块可简单插拔。配置文件可统一使用，也可以单独使用。支持测试环境和正式环境区分打包，用户角色权限管理，在线表单设计器，接口文档自动生成，多种方式的代码生成。 已确定结构 misalen-spring-common（100%）:常用工具包+基础支撑misalen-spring-core（20%）:与第三方对接的服务（微信支付，短信服务等）misalen-spring-db-jpa（100%）:持久化基础misalen-spring-system（100%）:系统设置（管理员、角色、用户管理等）misalen-spring-generator（60%）:自动化（代码生成、表单设计器、流程设计器） 将持续增加 misalen-spring-logback:日志服务中心misalen-spring-crawler:可订阅爬虫服务misalen-spring-test:自动化测试、测试用例、测试文档、postman脚本 MisalenSpring系列将持续更新 开源地址","categories":[{"name":"MisalenSpring","slug":"MisalenSpring","permalink":"https://misalen.github.io/categories/MisalenSpring/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/tags/SpringBoot/"},{"name":"Misalen","slug":"Misalen","permalink":"https://misalen.github.io/tags/Misalen/"}]},{"title":"Spring Boot -4- Shiro进阶","slug":"springboot-4-shiro进阶","date":"2017-12-19T01:46:18.000Z","updated":"2017-12-19T03:46:26.098Z","comments":true,"path":"2017/12/19/springboot-4-shiro进阶/","link":"","permalink":"https://misalen.github.io/2017/12/19/springboot-4-shiro进阶/","excerpt":"","text":"Shiro中重要的类 AuthorizingRealm继承关系：Realm-&gt;CachingRealm-&gt;AuthenticatingRealm-&gt;AuthorizingRealm主要方法：AuthenticatingRealm#getAuthenticationInfo（认证、获取认证信息） 123456789101112131415161718@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) UsernamePasswordToken token = (UsernamePasswordToken) authcToken; if (token == null || token.getUsername() == null) &#123; throw new UnsupportedTokenException(\"身份令牌异常\"); &#125; //从数据库中根据用户名查询 SysAdmin sysAdmin = sysAdminService.getByUsername(token.getUsername()); if (sysAdmin == null) &#123; throw new UnknownAccountException(\"用户名不存在\"); &#125; //辅助类 存的是用户名、用户id、昵称、用户的角色 ShiroUser shiroUser = new ShiroUser(sysAdmin.getPrimaryKey(), sysAdmin.getUsername()); shiroUser.setRoleSet(sysRoleService.findByAdminId(sysAdmin.getPrimaryKey())); shiroUser.setNickname(sysAdmin.getNickname()); // 返回SimpleAuthenticationInfo，Shiro会自动验证密码是否正确 return new SimpleAuthenticationInfo(shiroUser, sysAdmin.getLoginPwd(), getName());&#125; 主要方法：AuthorizingRealm#getAuthorizationInfo（获取用户角色） 12345678@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //因为登录验证的时候已经把用户角色放到辅助类里，在这直接取 ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(shiroUser.getRoleSet()); return info;&#125; AuthorizationFilter继承关系：…-&gt;AccessControlFilter-&gt;AuthorizationFilter主要方法：AccessControlFilter#isAccessAllowed(验证权限) 1234567891011121314151617181920@Overridepublic boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException &#123; Subject subject = getSubject(request, response); //需要的权限或角色，添加的时候是一个带‘,’的字符串，传过来的是一个数组 String[] roles = (String[]) mappedValue; boolean isPermitted = false; if (roles != null &amp;&amp; roles.length &gt; 0) &#123; for (String string : roles) &#123; //如果当前用户存在一个需要的角色就算通过 if (subject.hasRole(string)) &#123; isPermitted = true; break; &#125; &#125; &#125; else &#123; isPermitted = true; &#125; return isPermitted;&#125; 登录验证 调用顺序：Subject#login-&gt;SecurityManager#login-&gt;AuthenticatingSecurityManager#authenticate-&gt;AbstractAuthenticator#doAuthenticate-&gt;AuthenticatingRealm#getAuthenticationInfo 调用顺序：Subject#login-&gt;···-&gt;AuthenticatingRealm#getAuthenticationInfo123456789101112131415161718 Subject user = SecurityUtils.getSubject();UsernamePasswordToken token = new UsernamePasswordToken(username, password.toCharArray());token.setRememberMe(true);try &#123; user.login(token);&#125; catch (UnknownAccountException e) &#123; logger.error(\"账号不存在！\", e); return new ModelAndView(\"redirect:/login\");&#125; catch (DisabledAccountException e) &#123; logger.error(\"账号未启用！\", e); return new ModelAndView(\"redirect:/login\");&#125; catch (IncorrectCredentialsException e) &#123; logger.error(\"密码错误！\", e); return new ModelAndView(\"redirect:/login\");&#125; catch (RuntimeException e) &#123; logger.error(\"未知错误,请联系管理员！\", e); return new ModelAndView(\"redirect:/login\");&#125; 整体代码从数据库中查询权限和访问地址，使用自定义的登录和访问验证，用户拥有其中一个角色就能访问，例：地址访问的角色数组是[“admin”,”admin1”],用户角色是[“admin”,”admin2”]则能访问,[“admin3”,”admin4”]则不能访问 ShiroUser.java 辅助类暂存用户名、用户id、昵称和用户的角色12345678910111213141516171819202122232425import java.io.Serializable;import java.util.HashSet;import java.util.Set;/** * shiro用户对象，使得Subject除了携带用户的登录名外还可以携带更多信息 * * @author misalen * */public class ShiroUser implements Serializable &#123; private String userId; private String username; private Set&lt;String&gt; roleSet = new HashSet&lt;String&gt;(); private String nickname; public ShiroUser(String userId, String username) &#123; super(); this.userId = userId; this.username = username; &#125;//setter/getter&#125; ShiroConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.io.IOException;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import javax.servlet.Filter;import org.apache.shiro.cache.ehcache.EhCacheManager;import org.apache.shiro.codec.Base64;import org.apache.shiro.io.ResourceUtils;import org.apache.shiro.mgt.RememberMeManager;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.CookieRememberMeManager;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.apache.shiro.web.servlet.SimpleCookie;import org.misalen.system.service.SysRoleResourcesService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import net.sf.ehcache.CacheManager;@Configurationpublic class ShiroConfig &#123; @Autowired private SysRoleResourcesService sysRoleResourcesService; @Autowired private ShiroRealmDb shiroRealmDb; @Bean(\"shiroFilter\") public ShiroFilterFactoryBean shirFilter() &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager()); shiroFilterFactoryBean.setLoginUrl(\"/login\"); shiroFilterFactoryBean.setSuccessUrl(\"/home/\"); shiroFilterFactoryBean.setUnauthorizedUrl(\"/result/unauth\"); Map&lt;String, Filter&gt; filters = shiroFilterFactoryBean.getFilters(); filters.put(\"orRole\", new ShiroAuthorizationByRole()); shiroFilterFactoryBean.setFilters(filters); shiroFilterFactoryBean.setFilterChainDefinitionMap(loadFilterChainDefinitions()); return shiroFilterFactoryBean; &#125; private SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealmDb); securityManager.setCacheManager(ehCacheManager()); securityManager.setRememberMeManager(myRememberMeManager()); return securityManager; &#125; private RememberMeManager myRememberMeManager() &#123; CookieRememberMeManager manager = new CookieRememberMeManager(); manager.setCipherKey(Base64.decode(\"5aaC5qKm5oqA5pyvAAAAAA==\")); SimpleCookie cookie = new SimpleCookie(\"RememberMeManager\"); cookie.setHttpOnly(true); cookie.setMaxAge(7 * 24 * 60 * 60); manager.setCookie(cookie); return manager; &#125; private EhCacheManager ehCacheManager() &#123; CacheManager cacheManager = CacheManager.getCacheManager(\"es\"); if (cacheManager == null) &#123; try &#123; cacheManager = CacheManager .create(ResourceUtils.getInputStreamForPath(\"classpath:config/ehcache-shiro.xml\")); &#125; catch (IOException e) &#123; throw new RuntimeException(\"initialize cacheManager failed\"); &#125; &#125; EhCacheManager ehCacheManager = new EhCacheManager(); ehCacheManager.setCacheManager(cacheManager); return ehCacheManager; &#125; public Map&lt;String, String&gt; loadFilterChainDefinitions() &#123; Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); filterChainDefinitionMap.put(\"/**/css/**\", \"anon\"); filterChainDefinitionMap.put(\"/**/images/**\", \"anon\"); filterChainDefinitionMap.put(\"/plugins/**\", \"anon\"); filterChainDefinitionMap.put(\"/api/**\", \"anon\"); //这个地方是查询全部的&#123;\"地址\":\"角色\"&#125; List&lt;Object[]&gt; list = sysRoleResourcesService.getSystemPerm(); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 拼成&#123;\"地址\", \"角色，角色\"&#125;格式 for (Object[] objects : list) &#123; if (map.containsKey(objects[0])) &#123; map.put(objects[0].toString(), map.get(objects[0].toString()) + \",\" + objects[1].toString()); &#125; else &#123; map.put(objects[0].toString(), objects[1].toString()); &#125; &#125; //因为自定义角色验证用的是filters.put(\"orRole\", new ShiroAuthorizationByRole()); //所以角色用orRole[]包起来 for (Entry&lt;String, String&gt; objects : map.entrySet()) &#123; filterChainDefinitionMap.put(objects.getKey(), \"orRole[\" + objects.getValue() + \"]\"); &#125; filterChainDefinitionMap.put(\"/**\", \"user\"); return filterChainDefinitionMap; &#125;&#125; ShiroRealmDb.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authc.pam.UnsupportedTokenException;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.misalen.system.domain.SysAdmin;import org.misalen.system.service.SysAdminService;import org.misalen.system.service.SysRoleService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * shiro 自定义用户认证 * * @author misalen * */@Servicepublic class ShiroRealmDb extends AuthorizingRealm &#123; private static final Logger LOGGER = LogManager.getLogger(ShiroRealmDb.class); @Autowired private SysAdminService sysAdminService; @Autowired private SysRoleService sysRoleService; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException &#123; LOGGER.info(\"Shiro开始登录认证\"); UsernamePasswordToken token = (UsernamePasswordToken) authcToken; if (token == null || token.getUsername() == null) &#123; throw new UnsupportedTokenException(\"身份令牌异常\"); &#125; //查询用户 SysAdmin sysAdmin = sysAdminService.getByUsername(token.getUsername()); if (sysAdmin == null) &#123; throw new UnknownAccountException(\"用户名或密码错误\"); &#125; ShiroUser shiroUser = new ShiroUser(sysAdmin.getPrimaryKey(), sysAdmin.getUsername()); //查询用户角色 shiroUser.setRoleSet(sysRoleService.findByAdminId(sysAdmin.getPrimaryKey())); shiroUser.setNickname(sysAdmin.getNickname()); // LockedAccountException // DisabledAccountException return new SimpleAuthenticationInfo(shiroUser, sysAdmin.getLoginPwd(), getName()); &#125; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; LOGGER.info(\"Shiro获取用户角色和权限\"); ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles(shiroUser.getRoleSet()); return info; &#125;&#125; ShiroAuthorizationByRole.java 123456789101112131415161718192021222324252627282930313233import java.io.IOException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authz.AuthorizationFilter;public class ShiroAuthorizationByRole extends AuthorizationFilter &#123; /** * 自定义鉴权 true 通过 false 未通过 */ @Override public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException &#123; Subject subject = getSubject(request, response); String[] roles = (String[]) mappedValue; boolean isPermitted = false; if (roles != null &amp;&amp; roles.length &gt; 0) &#123; for (String string : roles) &#123; if (subject.hasRole(string)) &#123; isPermitted = true; break; &#125; &#125; &#125; else &#123; isPermitted = true; &#125; return isPermitted; &#125;&#125; 动态更新既然是数据库里查出的角色地址，必然是要有后台维护的，后台维护了就需要动态的更新权限控制。我采用了Spring的AOP来更新用户和系统。ShiroManage.java 更新系统权限12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Map;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;import org.apache.shiro.web.servlet.AbstractShiroFilter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;@Configurationpublic class ShiroManage &#123; @Autowired private ShiroFilterFactoryBean shiroFilterFactoryBean; @Autowired private ShiroConfig shiroConfig; public void updateSystemPermission() &#123; synchronized (shiroFilterFactoryBean) &#123; AbstractShiroFilter shiroFilter = null; try &#123; shiroFilter = (AbstractShiroFilter) shiroFilterFactoryBean.getObject(); &#125; catch (Exception e) &#123; throw new RuntimeException(\"get ShiroFilter from shiroFilterFactoryBean error!\"); &#125; PathMatchingFilterChainResolver filterChainResolver = (PathMatchingFilterChainResolver) shiroFilter .getFilterChainResolver(); DefaultFilterChainManager manager = (DefaultFilterChainManager) filterChainResolver.getFilterChainManager(); // 清空老的权限控制 manager.getFilterChains().clear(); shiroFilterFactoryBean.getFilterChainDefinitionMap().clear(); shiroFilterFactoryBean.setFilterChainDefinitionMap(shiroConfig.loadFilterChainDefinitions()); // 重新构建生成 Map&lt;String, String&gt; chains = shiroFilterFactoryBean.getFilterChainDefinitionMap(); for (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) &#123; String url = entry.getKey(); String chainDefinition = entry.getValue().trim().replace(\" \", \"\"); manager.createChain(url, chainDefinition); &#125; System.out.println(\"更新权限成功！！\"); &#125; &#125;&#125; 在ShiroRealmDb.java中增加方法更新用户角色123456789 //更新用户角色public void updateRole() &#123; PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals(); ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal(); super.clearCachedAuthorizationInfo(principals); if(shiroUser!=null)&#123; shiroUser.setRoleSet(sysRoleService.findByAdminId(shiroUser.getUserId())); &#125;&#125; ShiroAspect.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.misalen.common.shiro.ShiroManage;import org.misalen.common.shiro.ShiroRealmDb;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Aspect@Componentpublic class ShiroAspect &#123; @Autowired private ShiroManage shiroManage; @Autowired private ShiroRealmDb shiroRealmDb; @After(\"@annotation(updatePerm)\") public void updatePerm(JoinPoint point, UpdatePerm updatePerm) throws Throwable &#123; if (updatePerm.value()) &#123; shiroManage.updateSystemPermission(); &#125; &#125; @Before(\"@annotation(updateUser)\") public void beforeTest(JoinPoint point, UpdateUser updateUser) throws Throwable &#123; if (updateUser.value()) &#123; shiroRealmDb.updateRole(); &#125; &#125; @Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;) @Retention(RetentionPolicy.RUNTIME) public @interface UpdatePerm &#123; boolean value() default true; &#125; @Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;) @Retention(RetentionPolicy.RUNTIME) public @interface UpdateUser &#123; boolean value() default true; &#125;&#125; 什么时候更新用户角色？因为我的系统是首页嵌套iframe的形式，所以我在首页的Controller中加入@UpdateUser，每次刷新首页会重置用户的角色。什么时候跟新系统访问控制？修改资源（存地址的表）、删除资源、修改角色、删除角色、修改资源和角色关系时。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/tags/SpringBoot/"},{"name":"Shiro","slug":"Shiro","permalink":"https://misalen.github.io/tags/Shiro/"}]},{"title":"Spring Boot -3- 集成Shiro","slug":"springboot-3-集成shiro","date":"2017-12-19T01:46:17.000Z","updated":"2017-12-19T02:22:16.224Z","comments":true,"path":"2017/12/19/springboot-3-集成shiro/","link":"","permalink":"https://misalen.github.io/2017/12/19/springboot-3-集成shiro/","excerpt":"","text":"Shiro简介Apache Shiro是Java的一个安全框架，可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。这不就是我们想要的嘛，而且Shiro的API也是非常简单。 Shiro与Spring Security 1.Shiro没有Spring Security功能强大2.Spring Security的权限细粒度更高3.Shiro更简单，功能足够使用。 与SpringBoot集成添加Shiropom.xml文件中添加12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置ShiroSpring集成Shiro一般是在xml中配置Bean的，而SpringBoot不支持XML，直接使用@Configuration注入。 文件：ShiroConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.io.IOException;import java.util.LinkedHashMap;import java.util.Map;import javax.servlet.Filter;import org.apache.shiro.cache.ehcache.EhCacheManager;import org.apache.shiro.codec.Base64;import org.apache.shiro.io.ResourceUtils;import org.apache.shiro.mgt.RememberMeManager;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.CookieRememberMeManager;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.apache.shiro.web.servlet.SimpleCookie;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import net.sf.ehcache.CacheManager;@Configurationpublic class ShiroConfig &#123; @Bean(\"shiroFilter\") public ShiroFilterFactoryBean shirFilter() &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager()); shiroFilterFactoryBean.setLoginUrl(\"/login\");//登陆页面 shiroFilterFactoryBean.setSuccessUrl(\"/home/\");//登陆成功 shiroFilterFactoryBean.setUnauthorizedUrl(\"/result/unauth\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(loadFilterChainDefinitions()); return shiroFilterFactoryBean; &#125; /** * 权限管理器 * @return SecurityManager */ private SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setCacheManager(ehCacheManager()); securityManager.setRememberMeManager(myRememberMeManager()); return securityManager; &#125; /** * 记住密码管理器 * @return RememberMeManager */ private RememberMeManager myRememberMeManager() &#123; CookieRememberMeManager manager = new CookieRememberMeManager(); manager.setCipherKey(Base64.decode(\"5aaC5qKm5oqA5pyvAAAAAA==\")); SimpleCookie cookie = new SimpleCookie(\"RememberMeManager\"); cookie.setHttpOnly(true); cookie.setMaxAge(7 * 24 * 60 * 60); manager.setCookie(cookie); return manager; &#125; /** * 缓存管理器 * @return EhCacheManager */ private EhCacheManager ehCacheManager() &#123; CacheManager cacheManager = CacheManager.getCacheManager(\"es\"); //springboot热部署重启时CacheManager重新设置会报错 if (cacheManager == null) &#123; try &#123; cacheManager = CacheManager .create(ResourceUtils.getInputStreamForPath(\"classpath:config/ehcache-shiro.xml\")); &#125; catch (IOException e) &#123; throw new RuntimeException(\"initialize cacheManager failed\"); &#125; &#125; EhCacheManager ehCacheManager = new EhCacheManager(); ehCacheManager.setCacheManager(cacheManager); return ehCacheManager; &#125; /** * 地址-角色对应Map * @return Map */ public Map&lt;String, String&gt; loadFilterChainDefinitions() &#123; Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); filterChainDefinitionMap.put(\"/**/css/**\", \"anon\"); filterChainDefinitionMap.put(\"/**/images/**\", \"anon\"); filterChainDefinitionMap.put(\"/plugins/**\", \"anon\"); filterChainDefinitionMap.put(\"/**\", \"user\"); return filterChainDefinitionMap; &#125;&#125; Shiro基本配置完成","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/tags/SpringBoot/"},{"name":"Shiro","slug":"Shiro","permalink":"https://misalen.github.io/tags/Shiro/"}]},{"title":"Spring Boot -2- web应用","slug":"springboot-2-web应用","date":"2017-12-18T06:31:18.000Z","updated":"2017-12-19T03:47:03.495Z","comments":true,"path":"2017/12/18/springboot-2-web应用/","link":"","permalink":"https://misalen.github.io/2017/12/18/springboot-2-web应用/","excerpt":"","text":"最简单的web应用Spring运行环境不依赖其他中间件,而是把中间件集成到了项目中,默认使用tomcat.打开springboot项目,查看src/main/java下的Application文件,这个文件是springboot的启动类.1234567@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; web项目需要引入web相关的dependency如果在构建时没有选择web模块需要在pom.xml文件中添加1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 在Application同级包下创建TestController12345678@RestControllerpublic class TestController &#123; @RequestMapping(\"/\") public String greeting() &#123; return \"Hello World!\"; &#125;&#125; 运行Application,访问http://localhost:8080/ ,最简单的web应用完成. 有页面的web应用SpringBoot默认的页面不是jsp,而是thymeleaf模板,Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎,支持html的直接渲染.详情请移步官网thymeleaf 添加Thymeleafpom.xml文件中添加1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Thymeleaf配置说明1234567891011121314151617spring.thymeleaf.cache=true # Whether to enable template caching.spring.thymeleaf.check-template=true # Whether to check that the template exists before rendering it.spring.thymeleaf.check-template-location=true # Whether to check that the templates location exists.spring.thymeleaf.enabled=true # Whether to enable Thymeleaf view resolution for Web frameworks.spring.thymeleaf.enable-spring-el-compiler=false # Enable the SpringEL compiler in SpringEL expressions.spring.thymeleaf.encoding=UTF-8 # Template files encoding.spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also Thymeleaf's TemplateMode enum.spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.reactive.chunked-mode-view-names= # Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set.spring.thymeleaf.reactive.full-mode-view-names= # Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set.spring.thymeleaf.reactive.max-chunk-size= # Maximum size of data buffers used for writing to the response, in bytes.spring.thymeleaf.reactive.media-types= # Media types supported by the view technology.spring.thymeleaf.servlet.content-type=text/html # Content-Type value written to HTTP responses.spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved. 我的Thymeleaf配置配置文件是src/main/resources下的application.properties文件springboot默认查找src/main/resources和src/main/resources/config下的application.properties文件如果需要修改配置文件名称,启动的时候需要添加变量1234567public static void main(String[] args) throws IOException &#123; SpringApplication application = new SpringApplication(ServerApplication.class); Map&lt;String, Object&gt; map =new HashMap&lt;&gt;(); map.put(\"spring.config.name\", \"application\");//文件名称 application.setDefaultProperties(map); application.run(args);&#125; 我的Thymeleaf配置12345spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.cache: false #缓存开发环境最好关闭spring.thymeleaf.mode: html 开始使用Thymeleaf在src/main/resources/templates下新建html文件123456789&lt;!DOCTYPE html&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" &gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=\"$&#123;hello&#125;\"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在Application同级包下创建ThymeleafController12345678910@Controllerpublic class ThymeleafController &#123; @RequestMapping(\"/hello\") public ModelAndView helloHtml() &#123; ModelAndView andView = new ModelAndView(\"hello\"); andView.addObject(\"hello\", \"Hello Thymeleaf,DO·VIS?\"); return andView; &#125;&#125; 启动项目访问 http://localhost:8080/hello ,有页面的web应用完成,Thymeleaf的详细用法请访问官网或等待博主以后文章. 动态数据的web应用添加JPA在pom.xml文件中添加12345678910111213141516 &lt;!-- JPA --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt; 自定义方言默认Hibernate的存储引擎是InnoDB,如果有需要请改成MyISAM123456789import org.hibernate.dialect.MySQL5Dialect; public class MySQL5DialectUTF8 extends MySQL5Dialect&#123; @Override public String getTableTypeString() &#123; return \" ENGINE=InnoDB DEFAULT CHARSET=utf8\"; &#125; &#125; Druid配合配置创建文件DruidStatFilter1234567891011121314import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;import com.alibaba.druid.support.http.WebStatFilter;/** * 配置druid监控统计功能 配置Filter * */@WebFilter(filterName = \"druidWebStatFilter\", urlPatterns = \"/*\", initParams = &#123; @WebInitParam(name = \"exclusions\", value = \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\") &#125;)public class DruidStatFilter extends WebStatFilter &#123;&#125; 创建文件DruidStatViewServlet123456789101112131415161718192021222324252627282930import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import com.alibaba.druid.support.http.StatViewServlet;/** * 配置druid监控统计功能 * 在SpringBoot项目中基于注解的配置 * */@WebServlet(urlPatterns = \"/sys/druid/*\", initParams = &#123;// @WebInitParam(name = \"allow\", value = \"192.168.16.110,127.0.0.1\"), // IP白名单 (没有配置或者为空，则允许所有访问)// @WebInitParam(name=\"deny\",value=\"192.168.16.111\"), // IP黑名单 (存在共同时，deny优先于allow)// @WebInitParam(name=\"loginUsername\",value=\"druid\"),// 用户名// @WebInitParam(name=\"loginPassword\",value=\"druid\"),// 密码 @WebInitParam(name=\"resetEnable\",value=\"false\")// 禁用HTML页面上的“Reset All”功能 &#125;)public class DruidStatViewServlet extends StatViewServlet &#123; /** * */ private static final long serialVersionUID = 1L;&#125; JPA配置说明123456789101112spring.data.jpa.repositories.enabled=true # Whether to enable JPA repositories.spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the \"databasePlatform\" property.spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the \"Database\" enum.spring.jpa.generate-ddl=false # Whether to initialize the schema on startup.spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the \"hibernate.hbm2ddl.auto\" property. Defaults to \"create-drop\" when using an embedded database and no schema manager was detected. Otherwise, defaults to \"none\".spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.spring.jpa.hibernate.use-new-id-generator-mappings= # Whether to use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.spring.jpa.mapping-resources= # Mapping resources (equivalent to \"mapping-file\" entries in persistence.xml).spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.spring.jpa.properties.*= # Additional native properties to set on the JPA provider.spring.jpa.show-sql=false # Whether to enable logging of SQL statements. 我的JPA配置mysql数据库12345678910111213141516171819202122232425spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20spring.datasource.maxWait=60000spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20spring.datasource.filters=stat,wall,log4j2spring.datasource.useGlobalDataSourceStat=truespring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000;spring.datasource.url=jdbc:mysql://127.0.0.1:3306/misalentest?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=rootspring.jpa.database=MYSQLspring.jpa.show-sql=truespring.jpa.generate-ddl=false spring.jpa.database-platform=org.misalen.db.jpa.base.MySQL5DialectUTF8 #包名修改spring.jpa.hibernate.ddl-auto=update 连接配置创建文件 DruidDBConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.sql.SQLException;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Component;import com.alibaba.druid.pool.DruidDataSource;/** * 数据库连接池 * * @author zhaoguochao * */@Configuration@Componentpublic class DruidDBConfig &#123; // private Logger logger = LoggerFactory.getLogger(DruidDBConfig.class); @Value(\"$&#123;spring.datasource.url&#125;\") private String dbUrl; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; @Value(\"$&#123;spring.datasource.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;spring.datasource.initialSize&#125;\") private int initialSize; @Value(\"$&#123;spring.datasource.minIdle&#125;\") private int minIdle; @Value(\"$&#123;spring.datasource.maxActive&#125;\") private int maxActive; @Value(\"$&#123;spring.datasource.maxWait&#125;\") private int maxWait; @Value(\"$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;\") private int timeBetweenEvictionRunsMillis; @Value(\"$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;\") private int minEvictableIdleTimeMillis; @Value(\"$&#123;spring.datasource.validationQuery&#125;\") private String validationQuery; @Value(\"$&#123;spring.datasource.testWhileIdle&#125;\") private boolean testWhileIdle; @Value(\"$&#123;spring.datasource.testOnBorrow&#125;\") private boolean testOnBorrow; @Value(\"$&#123;spring.datasource.testOnReturn&#125;\") private boolean testOnReturn; @Value(\"$&#123;spring.datasource.poolPreparedStatements&#125;\") private boolean poolPreparedStatements; @Value(\"$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"$&#123;spring.datasource.filters&#125;\") private String filters; @Value(\"&#123;spring.datasource.connectionProperties&#125;\") private String connectionProperties; @Bean @Primary public DataSource dataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(this.dbUrl); datasource.setUsername(username); datasource.setPassword(password); datasource.setDriverClassName(driverClassName); // configuration datasource.setInitialSize(initialSize); datasource.setMinIdle(minIdle); datasource.setMaxActive(maxActive); datasource.setMaxWait(maxWait); datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); datasource.setValidationQuery(validationQuery); datasource.setTestWhileIdle(testWhileIdle); datasource.setTestOnBorrow(testOnBorrow); datasource.setTestOnReturn(testOnReturn); datasource.setPoolPreparedStatements(poolPreparedStatements); datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try &#123; datasource.setFilters(filters); &#125; catch (SQLException e) &#123; &#125; datasource.setConnectionProperties(connectionProperties); // Properties properties =new Properties(); // properties.setProperty(\"remarks\", \"true\"); //// properties.setProperty(\"useInformationSchema\", \"true\"); // datasource.setConnectProperties(properties); return datasource; &#125;&#125; 动态数据创建主键策略文件12345678910111213141516171819public class MysqlUUID &#123; @Id @GeneratedValue(generator = \"uuid\") @GenericGenerator(name = \"uuid\", strategy = \"uuid\") @ModelComment(\"主键\") @Column(length = 32, nullable = true) protected String primaryKey; public String getPrimaryKey() &#123; return primaryKey; &#125; public void setPrimaryKey(String primaryKey) &#123; this.primaryKey = primaryKey; &#125;&#125; 创建BaseModel12345678910111213141516171819202122232425262728293031323334import java.util.Date;import javax.persistence.Column;import javax.persistence.MappedSuperclass;import javax.persistence.Temporal;import javax.persistence.TemporalType;import org.hibernate.annotations.CreationTimestamp;import org.misalen.common.annotations.ModelComment;/** * * Sql数据库 Model基础类 * * */@MappedSuperclasspublic class BaseDomain extends MysqlUUID &#123; @ModelComment(\"添加时间\") @Column(updatable = false, nullable = false) @CreationTimestamp @Temporal(TemporalType.TIMESTAMP) private Date addTime; public Date getAddTime() &#123; return addTime; &#125; public void setAddTime(Date addTime) &#123; this.addTime = addTime; &#125;&#125; 创建用户Model12345678910@Entity@Tablepublic class SysAdmin extends BaseDomain &#123; @Column(length = 50, nullable = false) private String username; setget...&#125; 创建Repository123public interface SysAdminRepository extends JpaRepository&lt;SysAdmin, String&gt;, JpaSpecificationExecutor&lt;SysAdmin&gt; &#123; public SysAdmin getByUsername(String username);&#125; 创建Service12345678910@Servicepublic class SysAdminService&#123; @Autowired public SysAdminRepository sysAdminRepository; public SysAdmin getByUsername(String username) &#123; return sysAdminRepository.getByUsername(username); &#125;&#125; 在Controller中注入SysAdminService,动态数据的web页面完成.","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/tags/SpringBoot/"},{"name":"JPA","slug":"JPA","permalink":"https://misalen.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://misalen.github.io/tags/Hibernate/"},{"name":"thymeleaf3","slug":"thymeleaf3","permalink":"https://misalen.github.io/tags/thymeleaf3/"}]},{"title":"Spring Boot -1- 入门简介","slug":"springboot-1-简介入门","date":"2017-12-18T06:31:17.000Z","updated":"2017-12-18T07:27:42.638Z","comments":true,"path":"2017/12/18/springboot-1-简介入门/","link":"","permalink":"https://misalen.github.io/2017/12/18/springboot-1-简介入门/","excerpt":"","text":"版本: -SpringBoot-2.0.0.BUILD-SNAPSHOT -JDK1.8 什么是SpringBoot百度百科: Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。特点:123456-创建独立的Spring应用程序-嵌入的Tomcat，无需部署WAR文件-简化Maven配置-自动配置Spring-提供生产就绪型功能，如指标，健康检查和外部配置-绝对没有代码生成和对XML没有要求配置 怎么使用SpringBoot构建下载-连接到SpringBoot官方网站-点击top菜单栏的dos-点击Start a new Spring project-选择版本,填写Group和Artifact,填写需要的dependencies(web,hibernate…)-下载,把下载文件导入Maven项目到Eclipse,等待Maven加载完成 项目结构1234567891011|-demo(项目名称)| - src| | - main| | | - java| | | - resources| | | | - static| | | | - templates| | | | - application.properties| | - test| | | - java| - pom.xml dem：是项目名称; src/main/java:目录下放置所有java文件（源代码文件）; src/main/resources:放置所有的配置文件\\页面文件\\静态资源文件; src/main/resources/static:静态资源文件目录,在这个目录中的所有文件将可以被直接访问,如果没有这个文件夹可自行创建; src/main/resources/templates:网页文件目录,在这个目录中的所有文件将被thymeleaf模板引擎编译(下章会说明thymeleaf的使用); src/main/resources/application.properties:是配合文件,2.0的配置文档;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://misalen.github.io/tags/SpringBoot/"}]},{"title":"rxjava(4)多层嵌套简化","slug":"rxjava-4-多层嵌套简化","date":"2016-05-09T06:41:41.000Z","updated":"2017-12-18T02:07:10.805Z","comments":true,"path":"2016/05/09/rxjava-4-多层嵌套简化/","link":"","permalink":"https://misalen.github.io/2016/05/09/rxjava-4-多层嵌套简化/","excerpt":"","text":"rxjava版本：1.1.2由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作。示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Observable&lt;Integer&gt; myObservable = Observable.just(1)// .flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer i) &#123; System.out.println(\"调用顺序1&gt;&gt;\" + i); return Observable.just(++i); &#125; &#125;).flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer i) &#123; System.out.println(\"调用顺序2&gt;&gt;\" + i); return Observable.just(++i); &#125; &#125;).flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer i) &#123; System.out.println(\"调用顺序3&gt;&gt;\" + i); return Observable.just(++i); &#125; &#125;).flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer i) &#123; System.out.println(\"调用顺序4&gt;&gt;\" + i); return Observable.just(++i); &#125; &#125;).flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(Integer i) &#123; System.out.println(\"调用顺序5&gt;&gt;\" + i); return Observable.just(++i); &#125; &#125;);Action1&lt;Integer&gt; onNextAction = new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer i) &#123; System.out.println(\"结果&gt;&gt;\" + i); &#125;&#125;;myObservable.subscribe(onNextAction); 输出：123456调用顺序1&gt;&gt;1调用顺序2&gt;&gt;2调用顺序3&gt;&gt;3调用顺序4&gt;&gt;4调用顺序5&gt;&gt;5结果&gt;&gt;6 运用java8新特征lambda，将更加简便。","categories":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/categories/rxjava/"}],"tags":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/tags/rxjava/"}]},{"title":"rxjava(3)进阶Map/变换","slug":"rxjava-3-进阶Map变换","date":"2016-05-09T06:19:18.000Z","updated":"2017-12-18T02:07:11.286Z","comments":true,"path":"2016/05/09/rxjava-3-进阶Map变换/","link":"","permalink":"https://misalen.github.io/2016/05/09/rxjava-3-进阶Map变换/","excerpt":"","text":"rxjava版本：1.1.2本文引自：给 Android 开发者的 RxJava 详解RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 AP： 12345678910111213Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 传入string，转换成一个Bitmap这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。 &gt;map()： 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 &gt;flatMap()： 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： 12345678910111213141516Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String name) &#123; Log.d(tag, name); &#125; ...&#125;;Observable.from(students) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：1234567891011121314Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123; @Override public void onNext(Student student) &#123; List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) &#123; Course course = courses.get(i); Log.d(tag, course.getName()); &#125; &#125; ...&#125;;Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？ 这个时候，就需要用 flatMap() 了：12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。","categories":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/categories/rxjava/"}],"tags":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/tags/rxjava/"}]},{"title":"rxjava(2)多线程操作","slug":"rxjava-2-多线程操作","date":"2016-05-09T04:57:57.000Z","updated":"2017-12-18T02:07:10.179Z","comments":true,"path":"2016/05/09/rxjava-2-多线程操作/","link":"","permalink":"https://misalen.github.io/2016/05/09/rxjava-2-多线程操作/","excerpt":"","text":"rxjava版本：1.1.2如果你想给你的操作符链添加多线程，你可以通知这些操作符(或特定的Observables)运行在指定的调度器上。 也就是说RxJava的多线程是由Schedulers操作的,接下去去了解一下。 下面介绍两个操作符。 SubscribeOnSubscribeOn 指定了Observable的调度器. ObserveOn指定observer将会在哪个Scheduler观察这个Observable. 你可以使用subscribeOn()指定被观察者代码运行的线程，使用observerOn()指定观察者/订阅者运行的线程。例:加载图片并显示12345678910111213141516171819202122232425262728293031final int drawableRes = ...;final ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; //加载图片发生在io线程 Bitmap bmp = BitmapFactory.decodeResource(getResources(), drawableRes); Drawable drawable = new BitmapDrawable(getResources(), bmp); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; //设置图片被设定在了主线程 imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); AndroidSchedulers.mainThread()是在Android中才有。","categories":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/categories/rxjava/"}],"tags":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/tags/rxjava/"}]},{"title":"rxjava(1)入门HelloWord","slug":"rxjava-1-入门HelloWord","date":"2016-05-09T03:45:21.000Z","updated":"2017-12-18T02:07:10.813Z","comments":true,"path":"2016/05/09/rxjava-1-入门HelloWord/","link":"","permalink":"https://misalen.github.io/2016/05/09/rxjava-1-入门HelloWord/","excerpt":"","text":"rxjava版本：1.1.2RxJava：最核心的两个东西是Observables（被观察者，事件源）和Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。 一个Observable可以发出零个或者多个事件，直到结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。 Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。 maven下载12345&lt;dependency&gt; &lt;groupId&gt;io.reactivex&lt;/groupId&gt; &lt;artifactId&gt;rxjava&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; Hello World创建一个Observable对象很简单，直接调用Observable.create即可，这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。1234567Observable&lt;String&gt; myObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext(\"Hello, world!\"); sub.onCompleted(); &#125; &#125;); 接着我们创建一个Subscriber来处理Observable对象发出的字符串。这里subscriber仅仅就是打印observable发出的字符串。1234567891011121314Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;; 通过Observable的subscribe函数，可以把myObservable和mySubscriber进行关联，完成订阅。1myObservable.subscribe(mySubscriber); 完成订阅，控制台打印出：1Hello, world! 代码简化1234567891011121314151617181920212223242526272829303132//创建一个Observable对象很简单Observable&lt;String&gt; myObservable = Observable.just(\"Hello, world!\"); //分别创建 onNextAction onErrorAction onCompleteAction Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable s) &#123; System.out.println(s); &#125; &#125;; Action0 onCompleteAction = new Action0() &#123; @Override public void call() &#123; System.out.println(\"onCompleteAction\"); &#125; &#125;; myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction); //不在意结果和异常 // myObservable.subscribe(onNextAction); // 更简化 // Observable.just(\"Hello, world!\") // .subscribe(new Action1&lt;String&gt;() &#123; // @Override // public void call(String s) &#123; // System.out.println(s); // &#125; // &#125;); 参考文章：大头鬼Bruce","categories":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/categories/rxjava/"}],"tags":[{"name":"rxjava","slug":"rxjava","permalink":"https://misalen.github.io/tags/rxjava/"}]},{"title":"ubuntu部署MongoDB","slug":"ubuntu安装MongoDB","date":"2016-05-06T02:15:24.000Z","updated":"2017-12-18T02:07:09.517Z","comments":true,"path":"2016/05/06/ubuntu安装MongoDB/","link":"","permalink":"https://misalen.github.io/2016/05/06/ubuntu安装MongoDB/","excerpt":"","text":"ubuntu版本：14.04_x64 安装配置1234apt-get install mongo ###安装mongo ###进入mongo命令行use admin ###进入user表db.addUser('tank','test'); ###添加用户 权限及远程登录123vim /etc/mongodb.conf#bind_ip = 0.0.0.0 #bind_ip 127.0.0.1 添加注释 auth=true 去掉注释","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/tags/ubuntu/"},{"name":"mongo","slug":"mongo","permalink":"https://misalen.github.io/tags/mongo/"}]},{"title":"ubuntu部署mysql","slug":"ubuntu安装mysql","date":"2016-05-06T02:15:04.000Z","updated":"2017-12-18T02:07:09.846Z","comments":true,"path":"2016/05/06/ubuntu安装mysql/","link":"","permalink":"https://misalen.github.io/2016/05/06/ubuntu安装mysql/","excerpt":"","text":"ubuntu版本：14.04_x64mysql版本：5.6 1.安装软件包12345sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 2.操作123mysql -u root -p ###登录show databases; ###查看/etc/inint.d/mysqld start/stop/restart ###启动、停止、重启 3.问题不能远程连接问题1vim /etc/mysql/my.cnf 注释或删除1bind-address = 127.0.0.1 修改用户权限 12345678910mysql -u root -p mysql&gt;use mysql;mysql&gt;update user set host = '%' where user = 'root';mysql&gt;flush privileges;mysql&gt;select host, user from user;","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://misalen.github.io/tags/mysql/"}]},{"title":"ubuntu部署subversion","slug":"ubuntu安装subversion","date":"2016-05-06T02:14:54.000Z","updated":"2017-12-18T02:07:10.516Z","comments":true,"path":"2016/05/06/ubuntu安装subversion/","link":"","permalink":"https://misalen.github.io/2016/05/06/ubuntu安装subversion/","excerpt":"","text":"ubuntu版本：14.04_x64Subversion版本：1.8Eclipse插件要用1.10.x 在线安装地址：http://subclipse.tigris.org/update_1.10.x 1.安装软件包1sudo apt-get install subversion 2.准备123456### 创建文件夹sudo mkdir /usr/svn### 进入cd /usr/svn ### 创建版本仓库sudo svnadmin create /usr/svn/repos 3.配置1cd /usr/svn/repos/conf i.全局权限1sudo vim svnserve.conf 在 [general] 下 添加或者去掉注释1234anon-access = none #匿名用户不可读auth-access = write #权限用户可写passwdpassword-db = passwd #密码文件为authzauthz-db = authz #权限 ii.用户1sudo vim passwd 在[users]下 添加12#用户名=密码admin=admin iii.用户分组权限1sudo vim authz 在[groups]下添加1234567#分组名=用户,用户admin= admin[repos:/] #设置admin分组在所有文件夹都有读写权限@admin = rw #[repos:/media] #admin对repos版本库下media目录为读写权限#@admin = rw 4.启动1sudo svnserve -d -r /usr/svn/ 查看是否启动成功，可看的监听3690端口​1sudo netstat -antp |grep svnserve 5.停止1killall svnserve","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/tags/ubuntu/"},{"name":"svn","slug":"svn","permalink":"https://misalen.github.io/tags/svn/"},{"name":"subversion","slug":"subversion","permalink":"https://misalen.github.io/tags/subversion/"}]},{"title":"ubuntu部署Maven私服","slug":"ubuntu安装Maven私服","date":"2016-05-06T02:14:39.000Z","updated":"2017-12-18T02:07:11.338Z","comments":true,"path":"2016/05/06/ubuntu安装Maven私服/","link":"","permalink":"https://misalen.github.io/2016/05/06/ubuntu安装Maven私服/","excerpt":"","text":"ubuntu版本：14.04_x64Nexus地址： 地址链接，我的版本是nexus-2.13.0-01-bundle.tar.gz。 1.下载Nexus2.解压、移动1sudo tar -zxvf nexus-2.13.0-01-bundle.tar.gz -C /usr/maven 3.运行12cd /usr/maven./nexus start 可能报错1234****************************************WARNING - NOT RECOMMENDED TO RUN AS ROOT****************************************If you insist running as root, then set the environment variable RUN_AS_USER=root before running this script. 解决方案 i.退出root模式ii.修改%nexus_home%/bin/下的nexus,找到#RUN_AS_USER=改为RUN_AS_USER=root4.配置1234567访问：http://ip:8081/nexus登录：右上角login 默认用户名：admin 密码：admin123点击：Repositories&gt;&gt;Central-&gt;ConfigurationDownload Remote Indexes 更改为true 保存Public Repositories 全部都选过去分别右击：Central / Apache Snapshots/Snapshots/Public Repositoriesupdate update之后需要等很长很长时间，我是通过观察网速确认是否更新完的。 5.maven配置文件示例settings.xml ip改成真实ip1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;D:\\file\\maven\\repository&lt;/localRepository&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt; &lt;!-- snapshots 快照认证信息 --&gt; &lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Internal Repository Manager&lt;/name&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://123.56.69.30:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; pom.xml ip改成真实ip1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;nexustest&lt;/groupId&gt; &lt;artifactId&gt;nexustest&lt;/artifactId&gt; &lt;name&gt;nexustest&lt;/name&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;java-version&gt;1.8&lt;/java-version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;ddl-snapshots&lt;/id&gt; &lt;name&gt;ddl-snapshots&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;!-- 配置仓库的地址 --&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!-- 以下为 私服 及 插件 配置 id要和setting.xml中的对上 --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;nexus-releases&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;nexus-snapshots&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;additionalProjectnatures&gt; &lt;projectnature&gt;org.springframework.ide.eclipse.core.springnature&lt;/projectnature&gt; &lt;/additionalProjectnatures&gt; &lt;additionalBuildcommands&gt; &lt;buildcommand&gt;org.springframework.ide.eclipse.core.springbuilder&lt;/buildcommand&gt; &lt;/additionalBuildcommands&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;downloadJavadocs&gt;true&lt;/downloadJavadocs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf8&lt;/encoding&gt; &lt;compilerArgument&gt;-Xlint:all&lt;/compilerArgument&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;showDeprecation&gt;true&lt;/showDeprecation&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;org.test.int1.Main&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/categories/ubuntu/"}],"tags":[{"name":"nexus","slug":"nexus","permalink":"https://misalen.github.io/tags/nexus/"},{"name":"maven私服","slug":"maven私服","permalink":"https://misalen.github.io/tags/maven私服/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/tags/ubuntu/"}]},{"title":"ubuntu安装JDK","slug":"ubuntu安装JDK","date":"2016-05-06T02:14:11.000Z","updated":"2017-12-18T02:07:09.777Z","comments":true,"path":"2016/05/06/ubuntu安装JDK/","link":"","permalink":"https://misalen.github.io/2016/05/06/ubuntu安装JDK/","excerpt":"","text":"ubuntu版本：14.04_x64JDK地址: 地址链接，我的jdk版本是jdk1.8.0_77。 1.下载JDK2.解压、移动1sudo tar -zxvf jdk.tar.gz -C /usr/jdk 3.配置环境变量编辑profile1sudo vim /etc/profile 末尾添加 1export PATH=/usr/jdk/bin:$PATH 保存刷新，vim保存&gt;&gt;:wq 1source /etc/profile 编辑environment1sudo vim /etc/environment PATH中添加1;/usr/jdk/bin 末尾添加 12CLASS_PATH=\"/usr/jdk/lib\"JAVA_HOME=\"/usr/jdk\" 我的是这样123PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games;/usr/jdk/bin\"CLASS_PATH=\"/usr/jdk/lib\"JAVA_HOME=\"/usr/jdk\" 保存刷新 1source /etc/environment 4检测 1java -version","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://misalen.github.io/tags/ubuntu/"},{"name":"jdk","slug":"jdk","permalink":"https://misalen.github.io/tags/jdk/"}]}]}